# 课本典型例题汇总

本文档整理了《计算机组成与系统结构（微课版）》教材中的典型例题，涵盖了数据的机器表示、指令系统、运算方法、存储器、CPU及I/O系统等核心考点。

---

## 第二章 数据的机器层次表示

### 2-3
设机器数的字长为8位（含1位符号位），分别写出下列各二进制数的原码、补码和反码：
- 0
- -0
- 0.1000
- -0.1000
- 0.1111
- -0.1111
- 1101
- -1101

:::details 解析
**方法：** 正数三码合一；负数反码为原码数值位取反，补码为反码+1。

**详细答案：**
- $0$：$[原]=00000000, [补]=00000000, [反]=00000000$
- $-0$：$[原]=10000000, [补]=00000000, [反]=11111111$
- $0.1000$：$[原]=0.1000000, [补]=0.1000000, [反]=0.1000000$
- $-0.1000$：$[原]=1.1000000, [反]=1.0111111, [补]=1.1000000$
- $0.1111$：$[原]=0.1111000, [补]=0.1111000, [反]=0.1111000$
- $-0.1111$：$[原]=1.1111000, [反]=1.0000111, [补]=1.0001000$
- $1101$（整数）：$[原]=0,0001101, [补]=0,0001101, [反]=0,0001101$
- $-1101$（整数）：$[原]=1,0001101, [反]=1,1110010, [补]=1,1110011$

**注意：** 整数和小数的表示格式不同，整数用逗号分隔符号位和数值位，小数用小数点。
:::

### 2-4
写出下列各数的原码、补码和反码：
- 7/16
- 4/16
- 1/16
- ±0
- -1/16
- -4/16
- -7/16

:::details 解析
**方法：** 先转二进制。$7/16 = 0.0111_2$。

**详细答案（8位）：**
- $7/16 = 0.0111_2$：$[原]=0.0111000, [补]=0.0111000, [反]=0.0111000$
- $4/16 = 0.0100_2$：$[原]=0.0100000, [补]=0.0100000, [反]=0.0100000$
- $1/16 = 0.0001_2$：$[原]=0.0001000, [补]=0.0001000, [反]=0.0001000$
- $\pm 0$：$[原]=0.0000000$ 或 $1.0000000, [补]=0.0000000, [反]=0.0000000$ 或 $1.1111111$
- $-1/16 = -0.0001_2$：$[原]=1.0001000, [反]=1.1110111, [补]=1.1111000$
- $-4/16 = -0.0100_2$：$[原]=1.0100000, [反]=1.1011111, [补]=1.1100000$
- $-7/16 = -0.0111_2$：$[原]=1.0111000, [反]=1.1000111, [补]=1.1001000$
:::

### 2-9
若将第2-8题中的$[X]_原$改为$[X]_补$，结果如何？

> **注**：2-8题背景为$X=1.A_1A_2A_3A_4A_5A_6$，涉及$X > 1/2$或$1/8 \le X \le 1/4$等条件判断。

:::details 解析
**补码判断条件：** 若 $[X]_补 = 1.A_1A_2...A_6$，若要求 $X > -1/2$。

**分析：** 由于补码负数越小（绝对值越大）值越小，$X = -1/2$ 时补码为 $1.100000$。故 $X > -1/2$ 的条件是 $A_1$ 必须为 $1$（如 $1.101...$），且后面不能全为 $0$。

**具体条件：**
- $X > -1/2$：$A_1 = 1$，且 $A_2A_3A_4A_5A_6$ 不全为0
- $X = -1/2$：$A_1 = 1$，且 $A_2A_3A_4A_5A_6 = 00000$
- $X < -1/2$：$A_1 = 0$，或 $A_1 = 1$ 但 $A_2A_3A_4A_5A_6 = 00000$ 且其他条件

**注意：** 补码比原码在负数方向多表示一个值（$-1$ 或 $-2^n$）。例如8位补码范围是 $-128 \sim +127$，而原码是 $-127 \sim +127$。
:::

### 2-10
一个n位字长的二进制定点整数，其中1位为符号位，分别写出在补码和反码两种情况下，下列各情况的表示：
1. 模数
2. 最大的正数
3. 最负的数
4. 符号位的权
5. -1的表示形式
6. 0的表示形式

:::details 解析
**补码情况：**
1. **模数：** $2^n$（整数）
2. **最大的正数：** $2^{n-1}-1$（如8位为127）
3. **最负的数：** $-2^{n-1}$（如8位为-128）
4. **符号位的权：** $-2^{n-1}$（符号位为1时表示负数）
5. **-1的表示形式：** 全1（如8位为11111111）
6. **0的表示形式：** 全0（唯一表示）

**反码情况：**
1. **模数：** $2^n-1$（整数）
2. **最大的正数：** $2^{n-1}-1$
3. **最负的数：** $-(2^{n-1}-1)$（如8位为-127）
4. **符号位的权：** $-(2^{n-1}-1)$
5. **-1的表示形式：** $1,1111110$（除符号位外全1）
6. **0的表示形式：** $0,0000000$（+0）或 $1,1111111$（-0），有两种表示
:::

### 2-11
某计算机字长为16位，简述下列几种情况下所能表示数值的范围：
1. 无符号整数
2. 用原码表示定点小数
3. 用补码表示定点小数
4. 用原码表示定点整数
5. 用补码表示定点整数

:::details 解析
**16位字长表示范围：**

1. **无符号整数：** $0 \sim 2^{16}-1 = 0 \sim 65535$

2. **用原码表示定点小数：** $-(1-2^{-15}) \sim 1-2^{-15}$，即 $-0.999969... \sim 0.999969...$

3. **用补码表示定点小数：** $-1 \sim 1-2^{-15}$，即 $-1.0 \sim 0.999969...$

4. **用原码表示定点整数：** $-(2^{15}-1) \sim 2^{15}-1$，即 $-32767 \sim 32767$

5. **用补码表示定点整数：** $-2^{15} \sim 2^{15}-1$，即 $-32768 \sim 32767$

**注意：** 补码比原码在负数方向多表示一个值（定点整数多表示-32768，定点小数多表示-1.0）。
:::

### 2-16
某浮点数字长为12位，其中，阶符1位，阶码部分3位；数符1位，尾数部分7位。阶码以2为底，阶码和尾数均用补码表示。它所能表示的最大正数是多少？最小规格化正数是多少？绝对值最大的负数是多少？

:::details 解析
**浮点数格式：** 12位 = 阶符1位 + 阶码3位 + 数符1位 + 尾数7位

**阶码（3位补码）：** 范围 $-4 \sim +3$（即 $-2^2 \sim 2^2-1$）
- 最大正阶码：$011_2 = +3$
- 最小负阶码：$100_2 = -4$

**尾数（7位补码）：** 范围 $-1 \sim 1-2^{-6}$
- 最大正尾数：$0.111111_2 = 1-2^{-6} = 63/64$
- 最小正规格化尾数：$0.100000_2 = 1/2$
- 绝对值最大的负尾数：$1.000000_2 = -1$（补码表示）

**计算结果：**
1. **最大正数：** 最大正尾数 $\times 2^{最大正阶码} = (63/64) \times 2^3 = (63/64) \times 8 = 7.875$

2. **最小规格化正数：** 最小正规格化尾数 $\times 2^{最小负阶码} = (1/2) \times 2^{-4} = (1/2) \times (1/16) = 1/32 = 0.03125$

3. **绝对值最大的负数：** 绝对值最大的负尾数 $\times 2^{最大正阶码} = (-1) \times 2^3 = -8$
:::

### 2-18
一浮点数，其阶码部分为p位，尾数部分为q位，各包含1位符号位，均用补码表示；尾数基数r=2，该浮点数格式所能表示数的上限、下限及非零的最小正数是多少？写出表达式。

:::details 解析
**上限（最大正数）：** $(1-2^{-(q-1)}) \times 2^{2^{p-1}-1}$

**下限（最小负数，绝对值最大）：** $-1 \times 2^{2^{p-1}-1}$

**非零的最小正数：** $2^{-1} \times 2^{-2^{p-1}} = 2^{-2^{p-1}-1}$

其中：
- 阶码数值位有 $(p-1)$ 位，补码范围：$-2^{p-1} \sim 2^{p-1}-1$
- 尾数数值位有 $(q-1)$ 位，补码范围：$-1 \sim 1-2^{-(q-1)}$
:::

### 2-20
试将$(-0.1101)_2$用IEEE 754标准的短浮点数格式表示出来。

:::details 解析
**IEEE 754短浮点数格式：** 32位 = 符号位1位 + 阶码8位 + 尾数23位

**步骤：** 
1. **二进制转换：** $(-0.1101)_2 = -1.101 \times 2^{-1}$（规格化）

2. **符号位：** $S = 1$（负数）

3. **阶码计算：** 
   - 指数 = $-1$
   - 阶码 $E = -1 + 127 = 126 = (01111110)_2$

4. **尾数：** $M = 10100000000000000000000$（去掉小数点前的1，共23位，后面补0）

**最终结果：**
- **二进制：** `1 01111110 10100000000000000000000`
- **十六进制：** $BF500000H$（分组：1011 1111 0101 0000 0000 0000 0000 0000）

**验证：** $BF500000H = 10111111010100000000000000000000_2$
:::

### 2-27
已知下面数据块约定横向校验、纵向校验均为奇校验，指出至少有多少位出错。

> **注**：题目提供了一个8×4的数据矩阵及对应的校验位列表。

:::details 解析
**原理：** 奇校验要求数据中"1"的个数为奇数。若行/列校验同时发现不符，交叉点即为错位。

**方法：** 
1. 检查每行的横向校验位，找出不符合奇校验的行
2. 检查每列的纵向校验位，找出不符合奇校验的列
3. 出错位在不符合的行和列的交叉点
4. 至少出错位数 = 不符合的行数（或列数，取较大值）

如果只有1行和1列不符合，则至少1位出错；如果多行多列不符合，需要具体分析交叉点。
:::

---

## 第三章 指令系统

### 3-3
某计算机为定长指令字结构，指令长度为16位，每个操作数的地址码占6位，指令分为无操作数、单操作数和双操作数3类。若双操作数指令已有K种、无操作数指令已有L种，现问单操作数指令最多可能有多少种？

:::details 解析
**解析：** 16位指令，地址码 6位×2 = 12位。剩余4位做操作码，最多16种。若双操作数已用 K 种，则单操作数可选范围需根据"操作码扩展技术"计算：$(16-K) \times 2^6$。

**详细步骤：**
1. 双操作数指令：操作码4位，地址码12位（6位×2）
2. 若双操作数指令有K种，占用K个4位操作码
3. 剩余 $(16-K)$ 个4位操作码可用于扩展
4. 单操作数指令：操作码需要扩展，用 $(16-K)$ 个状态 + 6位地址码 = $(16-K) \times 2^6$ 种
5. 无操作数指令：在单操作数指令基础上继续扩展，用剩余状态 + 6位 = L种

因此，单操作数指令最多有 $(16-K) \times 2^6 - L/2^6$ 种（需要为无操作数指令预留空间）。
:::

### 3-4
设某计算机为定长指令字结构，指令长度为12位，每个地址码占3位，试提出一种分配方案，使该指令系统包含4条三地址指令、8条二地址指令、180条单地址指令。

:::details 解析
**关键：** 短操作码不能是长操作码的前缀。

**方案：** 
- 3位操作码前 4个状态（000-011）给三地址指令
- 剩下状态 $(8-4)=4$ 个状态（100-111）扩展用于二地址指令
- 二地址指令需要8条，用4个状态扩展：4×8=32种可能，但只需要8条，用其中8种
- 剩余状态继续扩展用于单地址指令：需要180条，用剩余状态扩展

**具体分配：**
- 三地址：操作码3位（000-011），地址码9位（3位×3）
- 二地址：操作码6位（100xxx-111xxx，其中前3位为100-111），地址码6位（3位×2）
- 单地址：操作码9位（在二地址基础上继续扩展），地址码3位
:::

### 3-10
某计算机字长为16位，主存容量为64K字，采用单字长单地址指令，共有64条指令。试说明：
1. 若只采用直接寻址方式，指令能访问多少个主存单元？
2. 若增加一位直接/间接标志，寻址范围如何？
3. 采用页面寻址方式（增加Z/C位）的效果。

:::details 解析
16位字长，$2^{16}=64K$。直接寻址范围受限于指令中地址字段的位数。

**分析：**
- 单字长指令：16位
- 64条指令：操作码需要6位（$2^6=64$）
- 剩余位数：16-6=10位用于地址

**(1) 直接寻址：** 地址字段10位，可访问 $2^{10}=1K$ 个主存单元

**(2) 增加直接/间接标志：** 
- 直接寻址：10位地址，访问1K单元
- 间接寻址：10位地址指向的单元内容（16位）作为有效地址，可访问全部64K单元

**(3) 页面寻址：** 
- Z/C位用于选择页号或页内地址
- 可以扩大寻址范围，例如用部分地址位作为页号，剩余作为页内地址
:::

### 3-13
计算下列4条指令的有效地址（指令长度为16位）：
1. 000000Q
2. 100000Q
3. 170710Q
4. 012305Q

> **假设**：采用八进制，最左边是间址位@，主存容量$2^{15}$，并给出了具体主存单元内容表。

:::details 解析
**数据背景（主存单元内容，八进制）：**
- (0) = 100002
- (1) = 046710
- (2) = 054304
- (3) = 100000
- (5) = 100001

**规则：** 八进制指令最高位为1表示间访（@），最高位为0表示直访。多级间址时，若单元内容最高位为1继续间访，为0则终止。

**具体计算：**

1. **000000Q：** 
   - 最高位为0，直接寻址
   - $EA = 000000Q = 0$

2. **100000Q：** 
   - 最高位为1，间访0号单元
   - 查(0)内容为100002，最高位为1，继续间访2号单元
   - 查(2)内容为054304，最高位为0，终止
   - $EA = 54304Q$

3. **170710Q：** 
   - 最高位为1，间访70710号单元
   - 需要查该单元内容，根据最高位判断是否继续间访
   - （具体计算需根据题目给出的主存内容表）

4. **012305Q：** 
   - 最高位为0，直接寻址
   - $EA = 12305Q$

**关键点：** 多级间址需要逐级查找，直到找到最高位为0的单元内容作为最终有效地址。
:::

### 3-14
假定某计算机的指令格式包括间址位、变址寄存器位、页选位及地址码A，计算在给定PC、I1、I2内容下的有效地址。

:::details 解析
**有效地址计算需要考虑多种寻址方式的组合：**

1. **直接寻址：** EA = A
2. **间接寻址：** EA = (A)
3. **变址寻址：** EA = (变址寄存器) + A
4. **页面寻址：** EA = (页寄存器) || A（页内地址拼接）

**组合情况：**
- 间址位=0，变址位=0：直接寻址
- 间址位=1，变址位=0：间接寻址
- 间址位=0，变址位=1：变址寻址
- 间址位=1，变址位=1：先变址后间址或先间址后变址（需看题目规定）
- 页选位：决定是否使用页面寻址

需要根据题目给出的PC、I1、I2的具体内容来计算。
:::

### 3-18
设相对寻址的转移指令占两字节，第一字节是操作码，第二字节是相对位移量（补码）。当前指令地址为2000H，计算执行JMP *+8和JMP *-9时，第二字节内容及目的地址。

:::details 解析
**相对寻址公式：** $目标地址 = (PC) + 指令长度 + 位移量$

**指令格式：** 双字节指令，第一字节操作码，第二字节相对位移量（补码）

**当前指令地址：** PC = 2000H

**JMP *+8：**
1. 取出指令后，PC = 2002H（PC + 2）
2. 目标地址 = 2002H + 0008H = 200AH
3. 位移量 = 08H（正数，补码与原码相同）

**JMP *-9：**
1. 取出指令后，PC = 2002H
2. 目标地址 = 2002H - 0009H = 1FF9H
3. 位移量 $-9$ 的补码计算：
   - $-9 = -(00001001)_2$
   - 补码：取反加1 = $(11110111)_2 = F7H$

**验证：** $2002H + F7H = 2002H - 9 = 1FF9H$ ✓

**注意：** 相对寻址的位移量是相对于下一条指令地址（PC+指令长度）的偏移，用补码表示。
:::

---

## 第四章 运算方法和运算器

### 4-6
已知X=0.1011, Y=-0.0101，求：
- $[1/2 X]_补$
- $[1/4 X]_补$
- $[-X]_补$
- $[1/2 Y]_补$
- $[1/4 Y]_补$
- $[-Y]_补$

:::details 解析
**位移运算：** $1/2 X$ 即右移一位。补码右移：符号位不变，左侧补符号位。

**求反运算：** $-X$：全位取反加1（含符号位）。

**具体计算：**
- $[X]_补 = 0.1011$，$[Y]_补 = 1.1011$（-0.0101的补码）
- $[1/2 X]_补 = 0.01011$（右移1位，符号位扩展）
- $[1/4 X]_补 = 0.001011$（右移2位）
- $[-X]_补 = 1.0101$（取反加1）
- $[1/2 Y]_补 = 1.11011$（符号位1扩展）
- $[1/4 Y]_补 = 1.111011$（符号位1扩展）
- $[-Y]_补 = 0.0101$（取反加1）
:::

### 4-8
分别用原码乘法和补码乘法计算X×Y：
1. X=0.11011, Y=-0.11111
2. X=-0.11010, Y=-0.01110

:::details 解析
**题目1：** X=0.11011, Y=-0.11111

**原码乘法：**
1. 符号位：$0 \oplus 1 = 1$（负数）
2. 数值位相乘：$0.11011 \times 0.11111$
   - 手算过程：逐位相乘并累加
   - 结果：$0.1101000101$
3. 最终结果：$1.1101000101$（符号位 + 数值位）

**补码乘法（Booth算法）：**
1. $[X]_补 = 0.11011$，$[Y]_补 = 1.00001$（-0.11111的补码）
2. 在乘数末位补0：$Y_{n+1} = 0$
3. 部分积初值为0
4. 根据 $y_i y_{i+1}$ 判断：
   - $y_0 y_1 = 10$：部分积 - $[X]_补$（即 + $[-X]_补$），然后右移
   - $y_1 y_2 = 00$：部分积右移
   - 继续按规则进行...
5. 最终得到补码乘积

**题目2：** X=-0.11010, Y=-0.01110
- 原码乘法：符号位 $1 \oplus 1 = 0$（正数），数值位相乘
- 补码乘法：按Booth算法逐步计算

**注意：** Booth算法可以处理负数乘法，避免符号位单独处理。
:::

### 4-9 (2)(4)
分别用原码加减交替法和补码加减交替法计算X÷Y：
- (2) X=-0.10101, Y=0.11011
- (4) X=-0.10110, Y=-0.11011

:::details 解析
**题目(2)：** X=-0.10101, Y=0.11011

**原码加减交替法：**
1. 符号位：$1 \oplus 0 = 1$（负数）
2. 数值位：$|X| = 0.10101$，$|Y| = 0.11011$
3. 运算过程：
   - 第一步：$|X| - |Y| = 0.10101 - 0.11011$（需要借位，结果为负）
   - 余数为负，商0，余数左移后加 $|Y|$
   - 余数为正，商1，余数左移后减 $|Y|$
   - 重复n次（n为尾数位数）
4. 最终：商 = $1.xxxxx$（符号位1），余数符号 = 被除数符号

**补码加减交替法：**
1. $[X]_补 = 1.01011$，$[Y]_补 = 0.11011$
2. 根据余数与除数符号：
   - 同号：商1，余数左移后减除数
   - 异号：商0，余数左移后加除数
3. 重复n次
4. 最后一步：余数不左移，根据符号调整商

**题目(4)：** X=-0.10110, Y=-0.11011
- 原码：符号位 $1 \oplus 1 = 0$（正数）
- 补码：$[X]_补 = 1.01010$，$[Y]_补 = 1.00101$，按补码除法规则计算

**注意：** 加减交替法避免了恢复余数法的复杂判断，效率更高。
:::

### 4-11 (1)
按照浮点数的运算规则计算：
- X=$2^{101} \times (-0.100010)$
- Y=$2^{100} \times (-0.111110)$

求X+Y, X-Y。

:::details 解析
**题目：** X=$2^{101} \times (-0.100010)$, Y=$2^{100} \times (-0.111110)$

**X+Y计算：**
1. **对阶：** Y的阶码小（100 < 101），Y的尾数右移1位，阶码+1
   - Y → $2^{101} \times (-0.011111)$
2. **尾数相加：** $-0.100010 + (-0.011111) = -1.000001$
   - 结果溢出（绝对值≥1），需要右规
3. **规格化：** 右规，尾数右移1位，阶码+1
   - 结果：$2^{110} \times (-0.1000001)$
4. **舍入：** 根据舍入规则处理
5. **溢出判断：** 检查阶码是否溢出

**X-Y计算：**
1. **对阶：** Y → $2^{101} \times (-0.011111)$
2. **尾数相减：** $-0.100010 - (-0.011111) = -0.100010 + 0.011111 = -0.000011$
   - 结果需要左规（尾数绝对值 < 0.5）
3. **规格化：** 左规，尾数左移，阶码减相应值
   - 左移3位：$-0.000011 \rightarrow -0.110000$，阶码减3
   - 结果：$2^{010} \times (-0.110000)$
4. **舍入和溢出判断**

**注意：** 浮点运算必须经过对阶、尾数运算、规格化、舍入、溢出判断五个步骤。
:::

---

## 第五章 主存储器

### 5-13
现有1024×1位的存储芯片，用它组成容量为16K×8位的存储器。求：
1. 所需芯片数量
2. 若分装在4K×8位的板上，地址线如何分配（选板、选片、片内地址）

:::details 解析
**(1) 所需芯片数量：**
- 总容量：$16K \times 8$ 位
- 芯片容量：$1K \times 1$ 位
- 芯片数 = $(16K \times 8) / (1K \times 1) = 128$ 片

**(2) 地址线分配（分装在4K×8位的板上）：**
- 总容量16K需要14根地址线（$2^{14} = 16K$）
- 每板4K×8位，需要 $16K / 4K = 4$ 块板
- 每板内：$4K / 1K = 4$ 组，每组8片（位扩展，1位→8位）

**地址分配方案：**
- **$A_0 \sim A_9$（10根）：** 片内地址（1K = $2^{10}$）
- **$A_{10} \sim A_{11}$（2根）：** 片选译码（选板内4组中的1组，每组8片并行）
- **$A_{12} \sim A_{13}$（2根）：** 板选译码（选4块板中的1块）

**连接方式：**
- 每块板：32片芯片（4组×8片）
- 板内：$A_{10}A_{11}$ 经2-4译码器选组
- 板间：$A_{12}A_{13}$ 经2-4译码器选板
- 数据线：每组8片并行，形成8位数据总线
:::

### 5-14
已知某计算机字长8位，地址线16位，使用1K×4位SRAM芯片组成最大主存空间，每块模板4K×8位，求模板数并画出连接逻辑图。

:::details 解析
**最大主存空间：** $2^{16} = 64K$ 地址，字长8位，总容量 = 64K×8位

**每块模板：** 4K×8位

**模板数：** 64K/4K = 16块模板

**每块模板内芯片数：** 
- 需要4K×8位
- 芯片1K×4位
- 位扩展：8/4 = 2片一组（位扩展）
- 字扩展：4K/1K = 4组
- 每块模板需要：2×4 = 8片

**地址分配：**
- $A_0 \sim A_9$：片内地址（1K）
- $A_{10} \sim A_{11}$：片选（4组）
- $A_{12} \sim A_{15}$：板选（16块板）

**连接逻辑：** 需要地址译码器、数据总线、控制信号等。
:::

### 5-16
利用2K×1位ROM、4K×1位RAM、8K×1位ROM组成16KB存储器（前4KB为ROM，后12KB为RAM），求芯片数量并画出逻辑图。

:::details 解析
**解析：** 前4KB地址 0000H-0FFFH 归 ROM，后12KB归 RAM。需用高位地址线（如 $A_{12} \sim A_{15}$）经译码器产生片选信号。

**ROM部分（4KB）：**
- 需要4KB = 4K×8位
- 可用2K×1位ROM：需要8片位扩展，2组字扩展 = 16片
- 或8K×1位ROM：需要8片位扩展，但8K>4K，需要地址限制

**RAM部分（12KB）：**
- 需要12KB = 12K×8位
- 用4K×1位RAM：需要8片位扩展，3组字扩展 = 24片

**地址分配：**
- ROM：0000H-0FFFH（$A_0 \sim A_{11}$片内，$A_{12}=0$选ROM）
- RAM：1000H-3FFFH（$A_0 \sim A_{11}$片内，$A_{12} \sim A_{13}$选RAM组，$A_{12}=1$选RAM区）
:::

### 5-17
用16K×1位DRAM构成64KB存储器。
1. 画出结构框图
2. 若读写周期0.5μs，选合理的刷新方式，计算刷新间隔和总刷新时间

:::details 解析
**(1) 结构框图：**
- 64KB = 64K×8位
- 芯片：16K×1位
- 芯片数 = $(64K \times 8) / (16K \times 1) = 32$ 片
- 结构：8片一组位扩展（1位→8位），4组字扩展（16K→64K）

**(2) 刷新方式选择：**
- **集中刷新：** 有死时间，不适合实时系统
- **分散刷新：** 每个读写周期后刷新一行，无死时间但速度慢
- **异步刷新（推荐）：** 刷新周期/行数 = 两次刷新的间隔

**异步刷新计算：**
- DRAM刷新周期：$2ms = 2000\mu s$
- 16K DRAM通常为128行矩阵（$2^7 = 128$）
- **刷新间隔：** $2ms / 128 = 15.625\mu s$
  - 即每 $15.6\mu s$ 产生一次刷新请求
- **总刷新时间：** $128 \times 0.5\mu s = 64\mu s$（假设刷新一行需要0.5μs）

**刷新安排：**
- 在2ms内分散刷新128行
- 每 $15.6\mu s$ 刷新一行
- 不影响正常读写操作（异步进行）

**注意：** 具体行数需要根据DRAM规格确定，常见的有128行、256行等。
:::

### 5-18
8位机单总线结构，地址16位，设计主存：
- 0-8191为系统ROM
- 8192-32767为用户区
- 最后2K为工作区

从给定芯片规格中选型并画出框图。

:::details 解析
**地址分配：**
- 系统ROM：0000H-1FFFH（8K = 8192字节）
- 用户区：2000H-7FFFH（24K = 24576字节，地址8192-32767）
- 工作区：最后2K，即F800H-FFFFH（2K = 2048字节）

**设计要点：**
1. 需要ROM芯片实现系统区
2. 需要RAM芯片实现用户区和工作区
3. 地址译码：用高位地址线区分不同区域
4. 单总线结构：地址总线、数据总线、控制总线共享

**地址译码：**
- $A_0 \sim A_{12}$：片内地址（8K需要13位）
- $A_{13} \sim A_{15}$：区域选择
  - 000-001：系统ROM（可能需要多片）
  - 010-111：用户RAM
  - 1111 1xxx：工作区（$A_{15}=1, A_{14}=1, A_{13}=1$）

需要根据题目给出的芯片规格选择合适的芯片。
:::

---

## 第七章 中央处理器

### 7-7
以一条典型的单地址指令为例，简要说明PC、IR、ALU、MDR、MAR在计算机取指周期和执行周期中的作用。

:::details 解析
**PC（程序计数器）：** 存放下一条指令地址。

**IR（指令寄存器）：** 存放当前指令。

**MAR（存储器地址寄存器）：** 内存地址缓冲，存放要访问的内存地址。

**MDR（存储器数据寄存器）：** 内存数据缓冲，存放从内存读出或要写入内存的数据。

**ALU（算术逻辑单元）：** 执行算术和逻辑运算。

**取指周期：**
1. PC → MAR（将指令地址送MAR）
2. 内存 → MDR（从内存读出指令）
3. MDR → IR（指令送IR）
4. PC+1 → PC（PC自增）

**执行周期（以ADD指令为例）：**
1. IR地址字段 → MAR（取操作数地址）
2. 内存 → MDR（读出操作数）
3. MDR → ALU，ACC → ALU（操作数送ALU）
4. ALU运算 → ACC（结果送累加器）
:::

### 7-8
指令和数据都存放在主存，如何识别从主存中取出的是指令还是数据？

:::details 解析
**结论：** 靠**时间段**和**控制信号**区分。在取指周期中从内存读出的是指令（送往 IR）；在执行周期中从内存读出的是数据（送往 ALU 或寄存器）。这是通过控制单元（CU）在不同时间发出的控制信号来区分的。

**具体说明：**
1. **取指周期：** 
   - PC提供地址 → MAR
   - 从内存取出的内容 → MDR → IR
   - 此时取出的是**指令**，由控制单元识别

2. **执行周期：** 
   - IR的地址字段提供地址 → MAR
   - 从内存取出的内容 → MDR → ALU或寄存器
   - 此时取出的是**数据**，用于运算或存储

**关键点：**
- 指令和数据在内存中无法区分（都是二进制代码）
- 通过**时间**（取指周期 vs 执行周期）和**控制信号**（CU发出的不同控制信号）来区分
- 取指周期：地址来自PC，内容送IR，控制信号为"取指"
- 执行周期：地址来自IR的地址字段，内容送运算部件，控制信号为"执行"

**本质：** 同一内存单元的内容，在不同时间、不同控制信号下，被解释为指令或数据。
:::

### 7-12
针对某计算机主要部件图：
1. 补充连接线
2. 写出指令ADD (R1), (R2)+ 的执行过程（含取指及自增型寄存器间址处理）

:::details 解析
**指令含义：** ADD (R1), (R2)+
- (R1)：R1的内容作为地址，该地址的内容作为源操作数
- (R2)+：R2的内容作为地址，该地址的内容作为目的操作数，然后R2自增

**取指周期：**
1. PC → MAR
2. Read, M(MAR) → MDR
3. MDR → IR
4. PC+1 → PC

**执行周期：**
1. R1 → MAR（R1内容作为地址）
2. Read, M(MAR) → MDR（取源操作数）
3. MDR → 暂存器（保存源操作数）
4. R2 → MAR（R2内容作为地址）
5. Read, M(MAR) → MDR（取目的操作数）
6. MDR → ALU, 暂存器 → ALU（两操作数送ALU）
7. ALU运算 → MDR（结果送MDR）
8. MDR → M(MAR)（写回目的地址）
9. R2+1 → R2（R2自增）

**连接线：** 需要PC→MAR、MAR→地址总线、数据总线→MDR、MDR→IR、R1/R2→MAR、ALU→MDR等。
:::

### 7-19
某计算机有8条微指令I1-I8，含有10种微命令a-j，已知每条微指令包含的微命令情况表，请安排操作控制字段格式（字段编码法）并代码化。

:::details 解析
**字段编码法：** 将互斥的微命令编在同一小组，经译码后发出。

**方法：** 将10个微命令 $a \sim j$ 分组。互斥的（不同时出现的）编在同一段。

**步骤：**
1. **分析微命令的互斥性：** 找出不能同时出现的微命令（互斥组）
   - 根据题目给出的微指令包含的微命令情况表，分析哪些微命令互斥
2. **分组示例：** 
   - 段1（$a, b, c$）：互斥的3个微命令
   - 段2（$d, e, f$）：互斥的3个微命令
   - 段3（$g, h, i, j$）：互斥的4个微命令
3. **计算位数：** 每组需要的位数 = $\lceil \log_2(互斥命令数+1) \rceil$（+1表示"不发命令"状态）
   - 段1：$\lceil \log_2(3+1) \rceil = 2$ 位（00空, 01a, 10b, 11c）
   - 段2：$\lceil \log_2(3+1) \rceil = 2$ 位（00空, 01d, 10e, 11f）
   - 段3：$\lceil \log_2(4+1) \rceil = 3$ 位（000空, 001g, 010h, 011i, 100j）
4. **代码化：** 为每个微命令分配编码，通常全0表示不发命令

**总位数：** $2 + 2 + 3 = 7$ 位

**注意：** 必须留出一个状态（通常是全0）表示"不发出任何命令"。如果有7个互斥的微命令，需要3位（$2^3=8$，其中000表示不发命令，001-111表示7个命令）。
:::

---

## 第八章 总线与输入/输出系统

### 8-2
假定某同步总线在一个时钟周期内传送一个4B的数据，总线时钟频率为33MHz，求总线带宽。若总线宽改为64位，频率改为66MHz且一个周期传两次，带宽提高多少倍？

:::details 解析
**总线带宽公式：** $BW = 频率 \times 宽度 \times 传输次数$

**(1) 初始带宽计算：**
- 总线时钟频率：33MHz
- 数据宽度：4B（每个时钟周期传送4B）
- $BW_1 = 33MHz \times 4B = 132MB/s$

**(2) 提高后带宽计算：**
- 总线宽度：64位 = 8B
- 总线频率：66MHz
- 传输方式：一个时钟周期传两次（双倍传输）
- $BW_2 = 66MHz \times 8B \times 2 = 1056MB/s$

**(3) 带宽提高倍数：**
- 提高倍数 = $1056 / 132 = 8$ 倍

**详细分析：**
- 宽度提高：$8B / 4B = 2$ 倍
- 频率提高：$66MHz / 33MHz = 2$ 倍
- 传输次数提高：$2$ 倍（每个周期传2次）
- 总提高：$2 \times 2 \times 2 = 8$ 倍

**验证：** $132 \times 8 = 1056MB/s$ ✓
:::

### 8-13
程序查询方式、程序中断方式、DMA方式各自适用什么范围？并判断一些关于它们相互替代的结论是否正确。

:::details 解析
**程序查询：** CPU踏步等待，效率低。
- **适用：** 低速设备，数据量小，实时性要求不高的场合
- **特点：** CPU利用率低，实现简单

**中断：** CPU与I/O并行。
- **适用：** 中低速设备，数据量中等，需要CPU处理的场合
- **特点：** CPU可以执行其他程序，响应速度较快

**DMA：** 直接内存存取，不经过CPU，适合高速大批量数据。
- **适用：** 高速设备，大批量数据传输，如磁盘、网络等
- **特点：** CPU利用率高，传输速度快，但需要DMA控制器

**相互替代：**
- 程序查询可以被中断方式替代（提高效率）
- 中断方式可以被DMA方式替代（进一步提高效率）
- 但DMA不能完全替代中断（中断还用于异常处理、实时响应等）
:::

### 8-21
设某机有5级中断L0-L4，响应优先次序为L0最高。要求将中断处理次序改为L1→L3→L0→L4→L2：
1. 设置各级屏蔽码
2. 画出5级同时请求时的进入处理过程图

:::details 解析
**目标处理顺序：** L1 > L3 > L0 > L4 > L2（L1优先级最高）

**屏蔽码规则：** 若1为屏蔽，0为允许（不屏蔽），则：
- 对自己和比自己优先级高的设为0（允许打断）
- 对自己和比自己优先级低的设为1（屏蔽）

**注意：** 题目中屏蔽码的定义可能不同，需根据题目说明。以下按"1为屏蔽，0为允许"的常见定义：

**各级屏蔽码设置：**

1. **L1的屏蔽字：** `11111`（最高优先级，屏蔽所有，包括自己）
   - L1=1, L3=1, L0=1, L4=1, L2=1
   - 或按另一种定义：L1=0（允许自己），L3=1, L0=1, L4=1, L2=1

2. **L3的屏蔽字：** `01010`（允许L1打断，屏蔽L0、L4、L2）
   - L1=0, L3=0（允许自己），L0=1, L4=1, L2=1

3. **L0的屏蔽字：** `01010`（允许L1、L3打断，屏蔽L4、L2）
   - L1=0, L3=0, L0=0（允许自己），L4=1, L2=1

4. **L4的屏蔽字：** `01000`（允许L1、L3、L0打断，屏蔽L2）
   - L1=0, L3=0, L0=0, L4=0（允许自己），L2=1

5. **L2的屏蔽字：** `00000`（最低优先级，允许所有打断）
   - L1=0, L3=0, L0=0, L4=0, L2=0（允许自己）

**处理过程（5级同时请求）：**
1. 响应L0（响应优先级最高，L0 > L1 > L2 > L3 > L4）
2. 进入L0处理，但L0屏蔽码允许L1、L3，所以L1可以打断L0
3. L1处理（最高处理优先级）
4. L1处理完后，继续L0
5. L0处理完后，处理L3
6. 依次处理L4、L2

**关键点：** 响应优先级和处理优先级可以不同，通过屏蔽码实现不同的处理顺序。
:::

---

---

## 说明

本文档整理了教材中的典型例题，供复习参考使用。建议结合教材和课件进行练习，掌握各类题型的解题方法。

---

## 📌 重点复习建议

根据历年考试情况，以下题目在考试中出现率极高，需要重点掌握：

### 核心大题（必考）

1. **3-13（地址变换 - 多级间址）**
   - 掌握多级间址的计算方法
   - 理解间址位的判断规则
   - 能够根据主存内容表计算有效地址

2. **5-13（存储器扩展）**
   - 掌握芯片数量的计算
   - 理解地址线的分配方法（片内、片选、板选）
   - 能够设计存储器的连接方案

3. **8-21（中断优先级 - 屏蔽码设置）**
   - 理解响应优先级和处理优先级的区别
   - 掌握屏蔽码的设置规则
   - 能够根据处理顺序设置各级屏蔽码

### 重要计算题

- **2-20（IEEE 754转换）**：浮点数格式转换，步骤必须完整
- **4-8、4-9（乘除法）**：原码和补码乘除法的计算过程
- **4-11（浮点运算）**：对阶、尾数运算、规格化的完整步骤
- **5-17（DRAM刷新）**：刷新方式的选择和计算

### 复习策略

1. **理解原理**：先理解基本概念和原理，再做题
2. **步骤完整**：计算题必须写出完整步骤，特别是IEEE 754转换
3. **多练习**：重点题目需要反复练习，确保熟练掌握
4. **查漏补缺**：结合教材和课件，补充题目中未给出的具体数值和表格
