# 7.6 流水线技术

流水线技术是将一个重复的过程分解为若干个子过程，每个子过程由专门的功能部件来实现。通过让多个任务在时间上重叠，并行处理，从而提高系统吞吐率。

---

## 7.6.1 基本概念

### 定义

**流水线技术**：将一个重复的过程分解为若干个子过程（段），每个子过程由专门的功能部件来实现，通过让多个任务在时间上重叠执行，实现并行处理。

### 工作原理

*   将指令执行过程划分为多个独立的阶段
*   不同指令的不同阶段在时间上重叠执行
*   每个阶段由专门的功能部件处理

### 典型指令流水线阶段

*   **IF (Instruction Fetch)**：取指令
*   **ID (Instruction Decode)**：译码
*   **EX (Execute)**：执行
*   **MEM (Memory Access)**：访存
*   **WB (Write Back)**：写回

---

## 7.6.2 主要性能指标

### 1. 吞吐率 (Throughput, TP)

*   **定义**：单位时间内流水线完成的任务数量
*   **公式**：
    $$TP = \frac{n}{T_k}$$
    其中：
    *   $n$：任务数量
    *   $T_k$：完成n个任务的总时间

*   **理想情况**：对于$k$段流水线，在流水线充满后，每个时钟周期完成一个任务
    $$TP_{\text{理想}} = \frac{1}{T_{\text{时钟}}}$$

### 2. 加速比 (Speedup, S)

*   **定义**：不使用流水线与使用流水线所花时间的比值
*   **公式**：
    $$S = \frac{T_{非流水}}{T_{流水}}$$

*   **理想情况**：$k$段流水线的加速比趋近于$k$
    $$S_{\text{理想}} \approx k$$

### 3. 效率 (Efficiency, E)

*   **定义**：流水线中各功能段的设备利用率
*   **公式**：
    $$E = \frac{n \text{个任务占用的时空区}}{k \text{个段占用的总时空区}}$$

*   **理想情况**：当流水线充满且无冲突时，效率接近100%

---

## 7.6.3 指令流水线的相关性问题（冲突/冒险）

流水线技术虽然能提高性能，但也会带来相关问题（Hazard），需要采用相应的解决方案。

### 1. 结构相关 (Structural Hazard)

#### 定义

因硬件资源冲突导致流水线无法正常执行。

#### 产生原因

*   多条指令同时访问同一硬件资源
*   例如：指令存储器和数据存储器共享同一物理存储器

#### 示例

| 时钟周期 | 指令₁ | 指令₂ | 指令₃ |
|:--------:|:-----:|:-----:|:-----:|
| 1 | IF | - | - |
| 2 | ID | IF | - |
| 3 | EX | ID | IF |
| 4 | MEM | EX | ID |
| 5 | WB | MEM | EX |

**冲突**：指令₁和指令₂在第4个时钟周期同时访问存储器（结构相关）

#### 解决方案

1. **插入暂停周期（阻塞/Stall）**：
   *   当发生资源冲突时，暂停后续指令的执行
   *   简单但效率低

2. **增加硬件资源**：
   *   分离的指令存储器和数据存储器（哈佛结构）
   *   增加功能部件（如多个ALU）

---

### 2. 数据相关 (Data Hazard)

#### 定义

后续指令需要使用前面指令的计算结果，但该结果尚未产生。

#### 类型

*   **RAW (Read After Write)**：写后读相关
    *   后续指令需要读取前面指令写入的数据
    *   最常见的数据相关类型

*   **WAR (Write After Read)**：读后写相关
    *   后续指令要写入前面指令读取的数据
    *   在乱序执行中可能出现

*   **WAW (Write After Write)**：写后写相关
    *   两条指令都要写入同一寄存器
    *   在乱序执行中可能出现

#### 示例（RAW相关）

$$\begin{aligned}
\text{ADD } R_1, R_2, R_3 &\quad \text{; } R_1 = R_2 + R_3 \\
\text{SUB } R_4, R_1, R_5 &\quad \text{; } R_4 = R_1 - R_5 \text{ (需要}R_1\text{的值)}
\end{aligned}$$

| 时钟周期 | ADD | SUB |
|:--------:|:---:|:---:|
| 1 | IF | - |
| 2 | ID | IF |
| 3 | EX | ID |
| 4 | MEM | EX |
| 5 | WB | MEM |

**冲突**：SUB在EX阶段需要ADD的结果，但ADD在WB阶段才写回（数据相关：RAW）

#### 解决方案

1. **阻塞流水线（Stall）**：
   *   插入空操作（NOP）或暂停流水线
   *   简单但会降低性能

2. **旁路/转发 (Bypassing/Forwarding)**：
   *   将计算结果从其产生的功能单元直接传送到需要它的其他功能单元
   *   不需要等待写回阶段
   *   这是最常用的解决方案

3. **指令重排序**：
   *   编译器或硬件重新安排指令顺序
   *   在相关指令之间插入无关指令

---

### 3. 控制相关 (Control Hazard)

#### 定义

由转移指令（分支、跳转）引起，当流水线无法确定下一条要执行的指令地址时发生。

#### 产生原因

*   转移指令的执行结果（是否跳转、跳转地址）在流水线后期才能确定
*   但流水线已经预取了后续指令

#### 示例

$$\begin{aligned}
\text{BEQ } R_1, R_2, \text{Label} &\quad \text{; 如果 } R_1 = R_2 \text{，跳转到Label} \\
\text{ADD } R_3, R_4, R_5 &\quad \text{; 下一条指令（可能不执行）}
\end{aligned}$$

| 时钟周期 | BEQ | ADD |
|:--------:|:---:|:---:|
| 1 | IF | - |
| 2 | ID | IF |
| 3 | EX | ID |
| 4 | MEM | EX |
| 5 | WB | MEM |

**冲突**：BEQ是否跳转在EX阶段才确定，但ADD已经在IF阶段被取入（控制相关）

#### 解决方案

1. **阻塞流水线**：
   *   等待转移指令结果确定后再继续
   *   简单但效率低

2. **分支预测 (Branch Prediction)**：
   *   **静态预测**：总是预测不跳转（或总是跳转）
   *   **动态预测**：根据历史信息预测（如分支历史表BHT）
   *   预测正确时性能好，预测错误时需要清空流水线

3. **延迟槽 (Delay Slot)**：
   *   在转移指令后安排一条总是执行的指令
   *   充分利用流水线

4. **多路预测**：
   *   同时取两条路径的指令
   *   确定路径后丢弃错误的路径

---

## 7.6.4 流水线性能优化

### 1. 增加流水线深度

*   将指令执行划分为更多阶段
*   可以提高时钟频率
*   但会增加相关性问题

### 2. 超标量技术

*   每个时钟周期发射多条指令
*   需要多个功能部件
*   需要更复杂的相关检测和解决机制

### 3. 乱序执行

*   允许指令不按程序顺序执行
*   需要更复杂的硬件支持
*   可以更好地利用硬件资源

---

## 总结

流水线技术通过将指令执行过程划分为多个阶段并让不同指令的不同阶段重叠执行，显著提高了处理器的吞吐率。主要性能指标包括吞吐率、加速比和效率。流水线技术也会带来结构相关、数据相关和控制相关等问题，需要采用相应的解决方案。现代处理器通过分支预测、旁路技术、超标量技术等多种方法进一步优化流水线性能。

