# 第3章 指令系统 - 专项练习

老师在录音里强调，第三章**指令系统**是整本书的重点之一。

他特别提醒：**大题必考指令格式设计（扩展操作码）和有效地址（EA）的计算**。在基础题部分，最容易挖坑的地方是**寻址方式的定义、各种寻址方式的访存次数，以及"PC+1"中的"1"代表的具体字节数**。

---

## 一、填空题（每空 1 分）

<FillInTheBlank
  :number="1"
  question="一条机器指令通常由 _________ 和 _________ 两部分组成。"
  :answer='["操作码（OP）", "地址码"]'
  explanation="指令的两大支柱：操作码指明操作类型，地址码指明操作数位置。"
/>

<FillInTheBlank
  :number="2"
  question="零地址指令的操作数通常由 _________ 隐含提供。"
  answer="堆栈（或栈顶单元）"
  explanation="零地址指令的核心特征：操作数从堆栈栈顶隐含获取，结果也压回栈顶。"
/>

<FillInTheBlank
  :number="3"
  question="扩展操作码技术的核心是：让地址码个数较少的指令，拥有长度较 _________ 的操作码。"
  answer="长"
  explanation="扩展操作码的设计初衷：地址码少的指令用更长的操作码来区分，从而在固定指令长度下支持更多指令类型。"
/>

<FillInTheBlank
  :number="4"
  question="_________ 寻址方式中，操作数就包含在指令中，取出指令即取出操作数。"
  answer="立即"
  explanation="立即寻址不需要访存，操作数直接包含在指令中，执行速度最快。"
/>

<FillInTheBlank
  :number="5"
  question="_________ 寻址方式最有利于编写浮动程序（即程序在内存中可以随机移动）。"
  answer="相对"
  explanation="老师强调：相对寻址只记偏移量，不记绝对地址，因此程序可以在内存中任意位置运行。"
/>

<FillInTheBlank
  :number="6"
  question="若指令长度为 32 位，按字节编址，PC 指向当前指令，则取指后 PC 自动加 _________。"
  answer="4"
  explanation="PC 更新陷阱：按字节编址，32位=4字节，取指后PC加4。"
/>

<FillInTheBlank
  :number="7"
  question="在 _________ 寻址中，有效地址 $EA$ 等于指令中给出的形式地址 $A$。"
  answer="直接"
  explanation="直接寻址：$EA=A$，形式地址就是有效地址，需要一次访存取操作数。"
/>

<FillInTheBlank
  :number="8"
  question="寄存器间接寻址中，有效地址 $EA$ 存放在 _________ 中。"
  answer="寄存器"
  explanation="形式地址 $R$ 指向寄存器，寄存器里存放的是有效地址 $EA$，需要一次访存取操作数。"
/>

<FillInTheBlank
  :number="9"
  question="程序控制类指令（如跳转指令）主要通过改变 _________ 的内容来实现程序的转移。"
  answer="程序计数器（PC）"
  explanation="程序控制类指令通过修改PC的值来改变程序执行顺序，实现跳转、调用等功能。"
/>

<FillInTheBlank
  :number="10"
  question="为了缩短指令长度，同时扩大寻址范围，可以采用 _________ 寻址或 _________ 寻址。"
  :answer='["间接", "寄存器间接"]'
  explanation="通过短地址找到长地址：间接寻址通过形式地址找到有效地址，寄存器间接寻址通过寄存器找到有效地址，都能扩大寻址范围。"
/>

---

## 二、单项选择题（每题 2 分）

<MultipleChoiceQuestion
  :number="1"
  question="（核心考点：访存次数）老师强调时间复杂度。不计取指，执行一次寄存器间接寻址的指令需访问（ ）次内存。"
  :options='[
    { key: "A", text: "0" },
    { key: "B", text: "1", explanation: "寄存器间接寻址：先从寄存器取有效地址EA（0次访存），再从EA取操作数（1次访存）。不计取指，共1次访存。" },
    { key: "C", text: "2" },
    { key: "D", text: "3" }
  ]'
  correct-answer="B"
/>

<MultipleChoiceQuestion
  :number="2"
  question="（重点：寻址速度）下列寻址方式中，执行速度最慢的是（ ）。"
  :options='[
    { key: "A", text: "立即寻址" },
    { key: "B", text: "寄存器寻址" },
    { key: "C", text: "直接寻址" },
    { key: "D", text: "间接寻址", explanation: "间接寻址至少要访问两次内存（先取有效地址，再取操作数），执行速度最慢。立即寻址和寄存器寻址都不需要访存，直接寻址只需1次访存。" }
  ]'
  correct-answer="D"
/>

<MultipleChoiceQuestion
  :number="3"
  question="（扩展操作码计算）设指令字长 16 位，每个地址码 4 位。若已有 14 条三地址指令，则最多还可以有（ ）条二地址指令。"
  :options='[
    { key: "A", text: "2" },
    { key: "B", text: "16" },
    { key: "C", text: "32", explanation: "16位指令，每个地址码4位，三地址指令操作码占16-3×4=4位，共2^4=16种编码。已用14条，剩余2个编码窗口。每个窗口可扩展2^4=16条二地址指令，共2×16=32条。" },
    { key: "D", text: "256" }
  ]'
  correct-answer="C"
/>

<MultipleChoiceQuestion
  :number="4"
  question="（相对寻址陷阱）某机指令长 2 字节，按字节编址。当前 PC 值为 2000H，执行一条相对寻址的跳转指令 JMP * + 8（* 为形式地址），则跳转的目标地址是（ ）。"
  :options='[
    { key: "A", text: "2008H" },
    { key: "B", text: "200AH", explanation: "录音陷阱：取指后PC先更新为2000H+2=2002H（指令长2字节），再加偏移量8，得200AH。相对寻址的基准是取指后的PC值。" },
    { key: "C", text: "2006H" },
    { key: "D", text: "2002H" }
  ]'
  correct-answer="B"
/>

<MultipleChoiceQuestion
  :number="5"
  question="（指令格式辨析）堆栈型计算机（Stack Machine）主要采用（ ）格式的指令。"
  :options='[
    { key: "A", text: "三地址" },
    { key: "B", text: "二地址" },
    { key: "C", text: "一地址" },
    { key: "D", text: "零地址", explanation: "堆栈型计算机使用栈顶隐含寻址，操作数从栈顶取，结果压回栈顶，因此主要采用零地址指令格式。" }
  ]'
  correct-answer="D"
/>

<MultipleChoiceQuestion
  :number="6"
  question="（寻址定义）形式地址为 $A$，寄存器 $R$ 的内容为 $(R)$。若有效地址 $EA = (R) + A$，则该寻址方式是（ ）。"
  :options='[
    { key: "A", text: "基址寻址" },
    { key: "B", text: "变址寻址" },
    { key: "C", text: "相对寻址" },
    { key: "D", text: "A 或 B 均可", explanation: "变址和基址在硬件逻辑上都是寄存器+形式地址。区别在于：基址寻址中寄存器内容不变（基址），变址寻址中寄存器内容可变（变址）。从公式看，两者都可以表示为EA=(R)+A。" }
  ]'
  correct-answer="D"
/>

<MultipleChoiceQuestion
  :number="7"
  question="（寄存器寻址优点）录音提到：使用寄存器寻址的主要目的是（ ）。"
  :options='[
    { key: "A", text: "扩大寻址范围" },
    { key: "B", text: "减少指令长度并提高速度", explanation: "寄存器编号短（如4位可表示16个寄存器），且寄存器访问速度快，不需要访存，因此可以减少指令长度并提高执行速度。" },
    { key: "C", text: "简化硬件设计" },
    { key: "D", text: "增加指令条数" }
  ]'
  correct-answer="B"
/>

<MultipleChoiceQuestion
  :number="8"
  question="（地址对齐陷阱）在按字节编址的计算机中，若 32 位长的数据（双字）存储在 2001H 开始的单元中，若要求边界对齐，则该存储方式（ ）。"
  :options='[
    { key: "A", text: "合法" },
    { key: "B", text: "不合法", explanation: "双字长4字节，边界对齐要求起始地址必须是4的整数倍。2001H不能被4整除（2001H=8193，8193 mod 4 = 1），因此不合法。" },
    { key: "C", text: "仅大端法合法" },
    { key: "D", text: "仅小端法合法" }
  ]'
  correct-answer="B"
/>

<MultipleChoiceQuestion
  :number="9"
  question="（指令类型）下列指令中，不属于程序控制类指令的是（ ）。"
  :options='[
    { key: "A", text: "调用指令（CALL）" },
    { key: "B", text: "转移指令（JMP）" },
    { key: "C", text: "逻辑左移指令（SHL）", explanation: "逻辑左移是运算类指令，不涉及程序流跳转。程序控制类指令包括：转移、调用、返回、中断等改变程序执行顺序的指令。" },
    { key: "D", text: "返回指令（RET）" }
  ]'
  correct-answer="C"
/>

<MultipleChoiceQuestion
  :number="10"
  question="（编址方式）老师提到班级号/宿舍号类比。将 I/O 端口地址和主存地址看作一个统一的地址空间，这种编址方式称为（ ）。"
  :options='[
    { key: "A", text: "独立编址" },
    { key: "B", text: "统一编址", explanation: "统一编址又称存储器映射寻址，将I/O端口和主存统一编址，使用相同的地址空间和访问指令。" },
    { key: "C", text: "混合编址" },
    { key: "D", text: "映射编址" }
  ]'
  correct-answer="B"
/>

---

## 参考答案与解析

### 一、填空题

1. **操作码（OP）、地址码**（指令的两大支柱）
2. **堆栈（或栈顶单元）**（零地址指令的核心特征）
3. **长**（扩展操作码的设计初衷）
4. **立即**（不需要访存，最快）
5. **相对**（老师强调：相对寻址只记偏移量，不记绝对地址）
6. **4**（$PC$ 更新陷阱：按字节编址，加号后面是指令的长度）
7. **直接**（$EA=A$）
8. **寄存器**（形式地址 $R$ 指向寄存器，寄存器里存 $EA$）
9. **程序计数器（PC）**
10. **间接、寄存器间接**（通过短地址找到长地址）

### 二、选择题

1. **B** - 一次去内存找有效地址 $EA$，如果还要取数，则是 $EA$ 对应单元
2. **D** - 间接寻址至少要访问两次内存，最慢
3. **C** - 三地址用掉 14 个，剩下 2 个窗口。每个窗口扩出 $2^4=16$ 条，总共 $2 \times 16 = 32$
4. **B** - 录音陷阱：取指后 PC 先更新为 $2000+2=2002H$，再加偏移量 8，得 200AH
5. **D** - 栈顶隐含寻址
6. **D** - 变址和基址在硬件逻辑上都是"寄存器+形式地址"
7. **B** - 寄存器编号短，且不需访存
8. **B** - 双字长 4 字节，起始地址必须是 4 的整数倍，2001H 不合法
9. **C** - 左移是运算类指令，不涉及程序流跳转
10. **B** - 统一编址又称存储器映射寻址

---

## 重点提示

1. **访存次数**：立即寻址和寄存器寻址0次，直接寻址和寄存器间接寻址1次，间接寻址2次
2. **PC更新陷阱**：取指后PC先更新（加指令长度），相对寻址的基准是更新后的PC值
3. **扩展操作码**：地址码少的指令用更长的操作码，通过编码窗口扩展
4. **边界对齐**：n字节数据起始地址必须是n的整数倍
5. **相对寻址**：最有利于编写浮动程序，只记偏移量不记绝对地址
6. **程序控制类指令**：通过改变PC值实现程序转移，包括跳转、调用、返回等
