# 2.1 数值数据的表示

本节主要介绍计算机中数值数据的基本表示方法，核心在于理解不同进制及其转换，以及带符号数的编码方式（原码、补码、反码）。

### 基础逻辑与核心概念

#### 1. 进位计数制

*   **基本概念**：
    *   **基数 (Radix)**：每个数位上可能出现的不同数码的个数。例如，二进制的基数是2，十进制是10。
    *   **位权 (Weight)**：数码在不同位置上所代表的数值大小。一个以 `r` 为基数的数可以表示为：
        $N = \sum_{i=-m}^{n-1} K_i \times r^i$
        其中 $K_i$ 是第 $i$ 位的数码。

*   **常见进制**：
    *   **二进制 (Binary)**：基数为2，数码为 0, 1。后缀 `B`。
    *   **八进制 (Octal)**：基数为8，数码为 0-7。后缀 `Q`。
    *   **十进制 (Decimal)**：基数为10，数码为 0-9。后缀 `D` (可省略)。
    *   **十六进制 (Hexadecimal)**：基数为16，数码为 0-9, A-F。后缀 `H`。

#### 2. 进制转换（易考点）

*   **任意进制转十进制**：使用按权展开法。
    *   示例: $(101.1)_2 = 1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 + 1 \times 2^{-1} = 4 + 0 + 1 + 0.5 = (5.5)_{10}$

*   **十进制转任意进制**：
    *   **整数部分**：除基取余法，余数倒序排列。
    *   **小数部分**：乘基取整法，整数顺序排列。

*   **二进制与八、十六进制的快速转换** (非常重要！)：
    *   **二进制转八进制**：从小数点开始，整数部分向左、小数部分向右，每3位一组，不足补0，然后将每组转换为对应的八进制数。
        *   示例：$(11011.1011)_2 \rightarrow (011\ 011.101\ 100)_2 \rightarrow (33.54)_8$
    *   **二进制转十六进制**：方法同上，但每4位一组。
        *   示例：$(11011.1011)_2 \rightarrow (0001\ 1011.1011)_2 \rightarrow (1B.B)_{16}$

#### 3. 无符号数与带符号数

*   **无符号数**：所有二进制位都用来表示数值，没有符号位。
*   **带符号数**：最高位为符号位，`0` 表示正数，`1` 表示负数。
    *   **真值**：带正负号的实际数值。
    *   **机器数**：在计算机中编码后的二进制表示。

#### 4. 原码、反码、补码 (核心难点与高频考点)

假设机器字长为 $n+1$ 位（1位符号位，n位数值位）。

*   **原码 `[X]_原`**：
    *   **定义**：符号位加上真值的绝对值的二进制。
    *   **正数**：符号位为0，数值位不变。$[+0.1011]_原 = 0.1011000$
    *   **负数**：符号位为1，数值位不变。$[-0.1011]_原 = 1.1011000$
    *   **特点**：
        *   直观，易于理解。
        *   0的表示不唯一：`[+0]_原` 和 `[-0]_原`。
        *   加减运算规则复杂。

*   **反码 `[X]_反`**：
    *   **定义**：
        *   正数的反码与其原码相同。
        *   负数的反码是其原码除符号位外，各位取反。
    *   **示例**：$X = -0.1011$, $[X]_原 = 1.1011000$, $[X]_反 = 1.0100111$
    *   **特点**：
        *   解决了负数加法问题，但仍存在 `+0` 和 `-0`。

*   **补码 `[X]_补`**：
    *   **定义**：
        *   正数的补码与其原码相同。
        *   负数的补码是其反码在最低位加1。
    *   **从真值求补码（负数）**：除符号位外，各位取反，末位加1。
    *   **从原码求补码（负数）**：除符号位外，各位取反，末位加1。
    *   **快速求法（负数）**：从真值二进制的最低位向左，找到第一个`1`，这个`1`及其右边的位保持不变，左边的所有位（不含符号位）取反。
    *   **示例**：$X = -0.1011$, $[X]_补 = 1.0101000$
    *   **特点 (非常重要！)**：
        *   **0的表示唯一**：`[+0]_补 = [-0]_补 = 0.000...`
        *   **加减法统一**：减法可以转换为加法来处理，$\[A-B\]_补 = \[A\]_补 + \[-B\]_补$。这是计算机采用补码的主要原因。
        *   **表示范围**：对于n位整数，补码比原码和反码能多表示一个负数。例如8位整数，原码范围是 `[-127, 127]`，补码是 `[-128, 127]`。

#### 5. 三种机器数的比较

| 特性 | 原码 | 反码 | 补码 |
| :--- | :--- | :--- | :--- |
| **正数** | 符号位为0，数值位为真值 | 与原码相同 | 与原码相同 |
| **负数** | 符号位为1，数值位为真值绝对值 | 符号位为1，数值位按位取反 | 符号位为1，数值位取反加1 |
| **零的表示** | 两种 (+0, -0) | 两种 (+0, -0) | 唯一 |
| **运算** | 加减法规则复杂 | 加法规则统一，但有循环进位 | 加减法规则完全统一 |
| **表示范围 (8位整数)** | -127 ~ +127 | -127 ~ +127 | -128 ~ +127 |

> **难点提示**：
> *   初学者很容易混淆 `[-B]_补` 和 `[[B]_补]_变补` 的区别。`[-B]_补` 是求B的相反数的补码。`[[B]_补]_变补` 是对B的补码这个机器数本身，连同符号位在内，全部按位取反，末位加1。
> *   习题中经常考察 `-128` (8位) 或 `-1` (定点小数) 的补码表示，需要特别注意。