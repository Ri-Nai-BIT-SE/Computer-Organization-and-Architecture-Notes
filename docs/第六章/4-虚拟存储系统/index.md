# 6.4 虚拟存储系统（详细笔记）

**核心概念**：虚拟存储器（Virtual Memory）是由**主存储器**（DRAM）和**辅助存储器**（磁盘）共同构成的存储层次。它为应用程序提供了一个比实际物理内存大得多的**逻辑地址空间**。

## 6.4.1 基本概念与特点

### 1. 定义与目标

*   **构成**：主存（实体）+ 辅存（虚体）。
*   **目标**：解决**容量**问题。在尽可能低的价格下，提供尽可能大的存储容量（接近辅存）和尽可能高的速度（接近主存）。
*   **透明性**：
    *   对**应用程序员**透明（他们只看到逻辑地址，觉得内存很大）。
    *   对**系统程序员**（OS开发者）不透明（需管理页面调度）。

### 2. Cache与虚拟存储系统的比较（重要考点）

| 比较项目 | **Cache存储系统** | **虚拟存储系统** |
| :--- | :--- | :--- |
| **目的** | 弥补主存**速度**的不足 | 弥补主存**容量**的不足 |
| **构成** | Cache + 主存 | 主存 + 辅存 (磁盘) |
| **实现方式** | 全部由**硬件**实现 | **OS软件** + 少量硬件支持 |
| **数据单位** | 块 (Block/Line) - 小 (几十字节) | 页 (Page) - 大 (1KB~4KB) |
| **速度比** | 几 : 1 | 几千/几万 : 1 (主存vs磁盘) |
| **失效处理** | CPU**不切换**线程，硬件自动处理 | CPU**切换**到其他进程 (Context Switch) |
| **透明性** | 对所有程序员透明 | 对应用程序员透明 |

### 3. 地址空间（三种）

1.  **虚拟/逻辑地址 (Virtual Address)**：程序员编写程序时使用的地址 (虚页号 + 页内偏移)。
2.  **主存/物理地址 (Physical Address)**：数据在内存中的实际地址 (实页号 + 页内偏移)。
3.  **辅存地址**：磁盘上的地址 (柱面、磁头、扇区)。

---

## 6.4.2 虚拟存储器的管理方式

主要有三种方式：**页式**、**段式**、**段页式**。

### 1. 页式管理 (Paging) —— 最普遍

**基本思想**：将主存和程序空间都切分成**固定大小**的块，称为**页 (Page)**。

*   **虚页 (Virtual Page)**：程序空间的页。
*   **实页/页框 (Page Frame)**：主存空间的页。
*   **地址变换**：`虚页号` $\to$ `实页号`。**页内偏移量保持不变**。
*   **页表 (Page Table)**：
    *   作用：记录虚页与实页的映射关系。
    *   位置：存放在**主存**中。
    *   **表项内容**：实页号、装入位 (Valid bit)、修改位 (Dirty bit)、访问权限等。
*   **多级页表**：
    *   原因：如果虚存空间很大（如4GB），页太小（如1KB），单级页表会非常大（4M个表项），难以连续存放。
    *   解决：采用多级页表（如页目录 -> 页表），只将当前需要的页表调入主存。

### 2. 段式管理 (Segmentation)

**基本思想**：按程序的**逻辑结构**（如代码段、数据段、堆栈段）自然分段，段长可变。

*   **地址结构**：`段号` + `段内偏移`。
*   **优点**：
    *   符合逻辑，模块化好。
    *   易于实现**存储保护**和**共享**（代码段只读共享）。
    *   动态链接容易。
*   **缺点**：
    *   内存分配复杂，容易产生**外部碎片**。
    *   地址变换需两次加法（段基址 + 偏移），速度慢。

### 3. 段页式管理 (Segmented Paging)

**基本思想**：先将程序**分段**，再将每个段**分页**。

*   **地址结构**：`段号` + `页号` + `页内偏移`。
*   **机制**：
    *   每个程序有一个**段表**。
    *   每个段有一个**页表**。
*   **优缺点**：集合了页式（内存利用率高）和段式（逻辑清晰）的优点，但需要**两次查表**（查段表得页表地址 $\to$ 查页表得物理页号），开销大。

---

## 6.4.3 提高访问速度的措施 —— TLB（快表）

由于页表存放在主存中，每次访存至少需要**两次**访问物理内存（一次查页表，一次取数据），速度太慢。

### 1. TLB (Translation Lookaside Buffer)

*   **定义**：一个高速、小容量的**相联存储器**，存放在CPU内部。
*   **别名**：转换后备缓冲器、快表。
*   **作用**：存放**近期最常访问**的页表项副本（根据局部性原理）。
*   **工作流程**：
    1.  CPU发出虚拟地址。
    2.  **同时**查找TLB（快表）和主存页表（慢表）。
    3.  **TLB命中**：直接得到物理地址，停止查慢表（只需1次访存）。
    4.  **TLB失效**：继续查主存页表，得到物理地址，并**更新TLB**。
        *   若TLB已满，需使用替换算法（如LRU）。

### 2. 性能分析

*   TLB命中率通常很高（>98%）。
*   一旦TLB命中，物理地址转换几乎不消耗额外时间。

---

## 6.4.4 页面替换与缺页处理

### 1. 缺页 (Page Fault)

*   **现象**：CPU访问的虚页对应的"装入位"为0（不在主存中）。
*   **处理**：
    1.  硬件产生**异常中断**。
    2.  操作系统（OS）响应，挂起当前进程。
    3.  启动I/O，将缺失的页从磁盘调入主存。
    4.  更新页表和TLB。
    5.  重新执行刚才的指令。

### 2. 替换算法

当主存已满，需要调入新页时，必须替换掉旧页。

*   **策略**：
    *   **FIFO**：先进先出，性能差。
    *   **LRU**：近期最少使用，性能好，OS通常采用近似实现（如时钟算法）。
*   **写回策略**：虚拟存储系统大多采用**写回法 (Write-Back)**。
    *   因为写磁盘太慢，只有在页面被替换出去时，才将修改过的脏页写回磁盘。

---

## 总结：CPU一次完整的访存操作流程

这是一个高频考点，涉及TLB、页表、Cache、主存的联动：

1.  **CPU给出虚拟地址**。
2.  **查TLB**：
    *   **Hit**：直接得到物理地址。
    *   **Miss**：查主存页表 $\to$ 得到物理地址 $\to$ 更新TLB。
        *   *注：若查页表发现"缺页"，则触发异常，OS从磁盘调页。*
3.  **得到物理地址后，查Cache**：
    *   **Hit**：直接传送数据给CPU（最快情况）。
    *   **Miss**：访问主存 $\to$ 取数据 $\to$ 送CPU并填入Cache。

**可能发生的三种失效**：

1.  **TLB失效**：需查主存页表（软/硬件处理）。
2.  **缺页 (Page Fault)**：需访问磁盘（最慢，OS处理）。
3.  **Cache失效**：需访问主存。

::: danger 包含关系（易混淆）
*   如果Cache命中，则主存和页面一定已调入（TLB可能有也可能没有，取决于设计，通常TLB先于Cache）。
*   如果发生缺页，则Cache和TLB一定不命中。
:::

---

## 6.4.5 核心例题

本章涉及的核心例题包括：

- **例6-10**：页表级数计算
- **例6-10扩展**：页表项大小计算
- **例6-10扩展2**：TLB命中率计算
- **例6-12**：综合访存流程分析（TLB + 页表 + Cache + 主存）

详细解题过程请参考：[核心例题详解](../核心例题详解.md)
