# 4.3 定点加减运算

本节是运算器的核心内容,重点讨论计算机如何使用补码来实现统一的加减运算,以及如何判断运算结果是否溢出。

## 核心概念

### 1. 原码加减运算

*   **特点**:符号位和数值位分开处理,规则复杂。
*   **流程**:先判断符号,同号相加,异号相减;减法还要判断绝对值大小以确定结果符号。
*   **缺点**:硬件实现复杂,需要加法器和减法器,不被现代计算机普遍采用。

:::details
好的，这是对您提供的关于**原码加减运算**那段文字的总结和示例。

#### 总结

这段文字的核心思想是，计算机在处理**原码 (sign-magnitude)** 表示的数字时，其加减法运算过程比较复杂，因为它需要将**符号**和**数值（绝对值）**分开处理。

主要的关键点如下：

1.  **运算的复杂性**：实际执行的是加法还是减法，不仅取决于指令本身，还和两个操作数的符号有关。例如，两个不同符号的数相加，实际上是对它们的绝对值做减法。
2.  **硬件简化**：为了简化硬件设计，计算机内部通常只设置**加法器**。所有的减法运算都会通过“求补”的方式转换为加法运算来完成。
3.  **原码运算规则**：
    *   **分离处理**：符号位不直接参与数值运算，运算只针对数的绝对值部分。
    *   **减法变加法**：当执行减法 `|X| - |Y|` 时，操作被转换为 `|X|` 加上 `|Y|` 的“变补”（通常指对数值部分求2's补码）。这个操作称为**前变补**。
    *   **结果判断**：通过检查数值部分最高位的**进位**来判断结果：
        *   **有进位**：表示运算结果是正确的正数。
        *   **无进位**：表示运算结果是一个负数，且当前得到的是其补码形式，需要再次进行“变补”（**后变补**）才能得到正确的绝对值。
    *   **确定符号**：最后，根据原始操作数和运算类型，独立地判断出结果的正确符号，并与计算出的绝对值组合成最终答案。

总而言之，原码的加减法流程是：**判断操作 -> 拆分出绝对值 -> 执行加法或变补加法 -> 根据进位判断是否需要二次变补 -> 单独确定符号位 -> 组合结果**。这个过程相比补码运算要繁琐得多。

---

#### 举例说明

我们用一个具体的例子来演示这个流程。假设机器的数值部分为4位。

##### 示例：计算 `(+5) - (+3)`

*   **原码表示**:
    *   X = +5  ->  `0 0101`
    *   Y = +3  ->  `0 0011`

**运算步骤**：

1.  **取绝对值**：
    *   `|X|` = `0101`
    *   `|Y|` = `0011`

2.  **判断操作**：
    *   指令是减法，因此需要将减数`|Y|`进行**前变补**（这里指求2's补码），然后与被减数`|X|`相加。
    *   `|Y|`的变补：`1101`
    *   执行加法：`0101 + 1101`

3.  **运算并判断进位**：
    ```
      0101  (|X|)
    + 1101  (|Y|的变补)
    -------
    1 0010
    ```
    *   运算结果为 `0010`，并且最高位产生了**进位 `1`**。
    *   根据规则“有进位，结果为正，即得到正确的结果”，所以数值部分就是 `0010`，并且不需要“后变补”。

4.  **结果加符号位**：
    *   因为是 `5 - 3`，结果应为正。所以符号位是 `0`。
    *   最终结果：`0 0010`，即 `+2`。

---
##### 反例：计算 `(+3) - (+5)`

1.  **取绝对值**：
    *   `|X|` = `0011`
    *   `|Y|` = `0101`

2.  **判断操作**：
    *   同样是减法，对 `|Y|` 进行**前变补**，然后与 `|X|` 相加。
    *   `|Y|` 的变补：`1011`
    *   执行加法：`0011 + 1011`

3.  **运算并判断进位**：
    ```
      0011  (|X|)
    + 1011  (|Y|的变补)
    -------
    0 1110
    ```
    *   运算结果为 `1110`，并且最高位**无进位 `0`**。
    *   根据规则“无进位，结果为负，则应再变一次补”，我们需要对 `1110` 进行**后变补**。
    *   `1110` 的变补（求2's补码）是 `0010`。这才是正确的绝对值结果。

4.  **结果加符号位**：
    *   因为是 `3 - 5`，结果应为负。所以符号位是 `1`。
    *   最终结果：`1 0010`，即 `-2`。
:::


### 2. 补码加减运算

*   **核心思想**:将减法转换为加法,统一使用加法器完成运算。符号位与数值位一同参与运算。
*   **补码加法公式**:$[X+Y]_补 = [X]_补 + [Y]_补 \pmod{2^{n+1}}$
*   **补码减法公式**:$[X-Y]_补 = [X]_补 + [-Y]_补 \pmod{2^{n+1}}$
    *   **求 $[-Y]_补$**:由 $[Y]_补$ **连同符号位在内,各位取反,末位加1**。

> 我们应将“某数的补码表示”与“变补”这两个概念区分开来。一个负数由原码表示转换成补码表示时，符号位是不变的，仅对数值位各位变反，末位加“1”。而变补则不论这个数的真值是正还是负，一律连同符号位一起变反（所有的二进制位一起变反），末位加“1”。$[Y]_补$表示的真值如果是正数，则变补后 $[-Y]_补$所表示的真值变为负数，反之亦然。

### 3. 溢出判断 (Overflow Detection)

*   **溢出**:运算结果超出了机器数所能表示的范围。
*   **发生条件**:**只有在两个符号相同的数相加时**才可能发生溢出(正正得负为正溢,负负得正为负溢)。两数异号相加,结果范围介于两数之间,绝不会溢出。

#### 溢出判断方法

**方法1: 单符号位法**

设操作数符号为 $X_s, Y_s$,结果符号为 $S_s$。

*   **溢出公式**:$V = X_s Y_s \overline{S_s} + \overline{X_s} \overline{Y_s} S_s$
*   **逻辑**:当且仅当操作数符号相同而结果符号与它们不同时,发生溢出。

**方法2: 双符号位法 (变形补码)**

采用两位符号位 $S_{s1}S_{s2}$。

*   `00`:正数
*   `11`:负数
*   `01`:正溢出
*   `10`:负溢出
*   **溢出公式**:$V = S_{s1} \oplus S_{s2}$
*   **逻辑**:当两个符号位不同时,表示溢出。这是硬件中最常用的判断方法。

**方法3: 进位判断法**

设符号位的进位为 $C_s$,最高数值位的进位为 $C_1$。

*   **溢出公式**:$V = C_s \oplus C_1$
*   **逻辑**:当符号位的进位与最高数值位的进位不同时,表示溢出。

## 易考点与难点

> **易考点**:
> *   补码加减法的基本运算规则,特别是如何求 $[-Y]_补$。
> *   符号扩展:将一个短位数的补码扩展为长位数时,正数补0,负数补1(即用符号位填充)。

> **难点**:**溢出判断是本章的重中之重,也是考试的绝对热点和难点**。必须熟练掌握上述三种溢出判断方法,并能灵活运用。特别是双符号位法和进位判断法,需要通过大量练习来理解其原理。
