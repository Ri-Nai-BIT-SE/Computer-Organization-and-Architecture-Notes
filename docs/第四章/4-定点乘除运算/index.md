# 4.4 定点乘除运算

本节介绍定点数乘法和除法的硬件实现方法,重点是原码一位乘法和补码一位乘法(布斯算法)。

## 核心概念

### 1. 原码一位乘法

*   **思想**:模拟手算乘法,但通过"加法-移位"实现。
*   **规则**:
    1.  符号位单独处理,结果符号为 $P_s = X_s \oplus Y_s$。
    2.  数值部分进行运算。设置累加器A(初值为0)、乘数寄存器C、被乘数寄存器B。
    3.  循环n次(n为数值位数):
        *   判断乘数C的最低位:
            *   若为1,则 A = A + |B|。
            *   若为0,则 A = A + 0。
        *   将A和C作为一个整体逻辑右移一位。
*   **结果**:乘积的高位在A中,低位在C中。

### 2. 补码一位乘法 (布斯算法 - Booth's Algorithm)

*   **思想**:直接对补码进行运算,无需转换,符号位也参与运算。
*   **规则**:
    1.  被乘数 $[X]_补$ 和部分积(累加器A)采用双符号位。
    2.  在乘数 $[Y]_补$ 的最低位后增加一位辅助位 $Y_{n+1}$,初值为0。
    3.  循环n+1次:
        *   根据乘数寄存器最低两位 $Y_n Y_{n+1}$ 的值进行操作:
            *   `01`:A = A + $[X]_补$
            *   `10`:A = A + $[-X]_补$
            *   `00` 或 `11`:A = A + 0
        *   将A和Y作为一个整体进行**算术右移**一位。
*   **注意**:最后一步不移位。结果在A和Y中(不包括 $Y_{n+1}$)。

### 3. 原码除法 (加减交替法 / 不恢复余数法)

*   **思想**:模拟手算除法,通过比较被除数(或部分余数)和除数的大小来决定商上1还是上0。
*   **规则**:
    1.  符号位单独处理,$Q_s = X_s \oplus Y_s$。
    2.  如果部分余数为正,减去除数;如果为负,加上除数。
    3.  根据新的部分余数符号来确定商:
        *   如果新余数与除数同号,说明够减,商上1。
        *   如果新余数与除数异号,说明不够减,商上0。
    4.  将余数左移一位,继续下一轮。
    5.  最后若余数为负,需加上除数进行一次**恢复**。

### 4. 补码除法 (加减交替法)

*   **规则**:与原码除法类似,但所有数都用补码表示。
*   **上商规则**:
    *   如果部分余数和除数**同号**,商上1,下次操作为:**余数左移一位,减去除数**。
    *   如果部分余数和除数**异号**,商上0,下次操作为:**余数左移一位,加上除数**。
*   **末位恒置1**:为简化硬件,商的最后一位可以直接置1,但会引入误差。

## 易考点与难点

> **难点**:**布斯算法是本节的核心难点和高频考点**。需要准确记忆 $Y_n Y_{n+1}$ 的四种情况对应的操作,并熟练进行补码的算术右移。手算过程很容易出错。

> **难点**:补码除法的上商规则和余数修正比较复杂,特别是符号的判断。

> **易考点**:
> *   原码一位乘法的流程相对简单,是理解乘法硬件实现的基础。
> *   理解乘法需要n次加法和n次移位,而除法需要n+1次加/减和n次移位。
