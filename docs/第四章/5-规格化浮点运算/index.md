# 4.5 规格化浮点运算

本节介绍浮点数的加、减、乘、除运算过程。浮点运算比定点运算复杂,因为它涉及阶码和尾数两部分的独立和关联操作。

## 核心概念

### 1. 浮点加减运算步骤

浮点加减运算的核心是"先对阶,再求和/差"。

#### 步骤1: 0操作数检查

检查是否有操作数为0,若有则可简化运算。

#### 步骤2: 对阶 (Exponent Alignment)

*   **目的**:使两个数的阶码相等,才能进行尾数相加减。
*   **规则**:**小阶向大阶看齐**。
*   **操作**:将阶码小的数的尾数**右移**,每右移一位,其阶码加1,直到两个阶码相等。右移出的低位将被舍去,造成精度损失。

#### 步骤3: 尾数加/减 (Mantissa Operation)

将对阶后的两个尾数按定点加减法规则进行运算。

#### 步骤4: 结果规格化 (Normalization)

*   **目的**:将运算结果转换为标准的浮点数格式,以保证精度。
*   **左规 (Left Shift)**:当尾数绝对值小于 $1/2$ 时(补码表示为 `00.0...` 或 `11.1...`),需要左规。将尾数**左移**一位,阶码**减1**,直到尾数规格化为止。可能需要多次左规。
*   **右规 (Right Shift)**:当尾数运算发生溢出时(补码双符号位为 `01` 或 `10`),需要右规。将尾数**右移**一位,阶码**加1**。右规最多只需一次。

#### 步骤5: 舍入处理 (Rounding)

在对阶和右规过程中,可能会丢失精度,需要根据舍入规则进行处理。

#### 步骤6: 溢出判断 (Overflow Check)

检查最终的**阶码**是否超出其表示范围。阶码上溢(超过最大值)或下溢(小于最小值)都会导致运算失败。尾数溢出在规格化步骤中已经处理。

### 2. 浮点乘除运算步骤

#### 步骤1: 阶码运算

*   **乘法**:阶码相加。$[E_x + E_y]_补$
*   **除法**:阶码相减。$[E_x - E_y]_补$
*   **注意**:如果阶码是用移码表示,相加后要减去一个偏置值,相减后要加上一个偏置值。

#### 步骤2: 尾数运算

*   **乘法**:尾数相乘。
*   **除法**:尾数相除。

#### 步骤3: 结果规格化、舍入、溢出判断

对尾数运算结果进行规格化,并进行相应的舍入和溢出检查。

## 易考点与难点

> **难点**:**浮点加减法的完整步骤是本章最难、最综合的考点**。每一步都不能出错,特别是:
> *   **对阶**:谁移?移几位?怎么移?
> *   **规格化**:何时左规?何时右规?阶码如何变化?
> *   整个流程涉及定点加减、移位、溢出等多个知识点,综合性极强。

> **易考点**:
> *   浮点乘除法的步骤相对固定(阶码相加/减,尾数相乘/除),比加减法简单。
> *   理解浮点数运算中,**对阶**是加减法特有的,而乘除法没有这一步。
