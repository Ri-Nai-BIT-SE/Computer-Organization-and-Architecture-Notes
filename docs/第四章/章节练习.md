# 第4章 运算方法和运算器 - 专项练习

老师在录音里对第四章**运算方法和运算器**发出了最严厉的警告：**这章是大题重灾区，乘除法运算过程必须一步步写清，只给个答案一分没有！**

在基础题部分，老师强调了**算术移位规则（尤其是负数补码）、溢出判断（双符号位）、Booth算法的判定逻辑、以及浮点数对阶原则**。

---

## 一、填空题（每空 1 分）

<FillInTheBlank
  :number="1"
  question="一位全加器（FA）共有 _________ 个输入端和 _________ 个输出端。"
  :answer='["3", "2"]'
  explanation="输入：A, B, Ci-1（三个输入）；输出：S（和）, Ci（进位，两个输出）。"
/>

<FillInTheBlank
  :number="2"
  question="并行加法器中，提高运算速度的关键是采用 _________ 技术，通过 $G_i$ 和 $P_i$ 信号提前产生进位。"
  answer="先行进位（或快速进位）"
  explanation="先行进位技术通过生成信号G_i和传播信号P_i提前计算所有进位，避免逐级传递的延迟。"
/>

<FillInTheBlank
  :number="3"
  question="补码加减运算中，若采用双符号位（变形补码），结果符号为01表示发生 _________ 溢出，11表示结果为 _________。"
  :answer='["正", "负数"]'
  explanation="录音陷阱：双符号位 01正溢，10负溢，11负数，00正数。"
/>

<FillInTheBlank
  :number="4"
  question="在补码一位乘法（Booth 算法）中，如果 $y_n y_{n+1} = 01$，则下一步操作是部分积加 _________。"
  answer="$[X]_{补}$"
  explanation="Booth算法：01加补码，10加负补码，00或11只移位。"
/>

<FillInTheBlank
  :number="5"
  question="补码一位乘法（Booth 算法）共需进行 $n+1$ 次加法和 _________ 次移位，且最后一次加法 _________（移位/不移位）。"
  :answer='["n", "不移位"]'
  explanation="老师强调：Booth法最后一步只加不移，共n+1次加法，n次移位。"
/>

<FillInTheBlank
  :number="6"
  question="对补码表示的负数进行算术右移，左边空出的位应填入 _________。"
  answer="1"
  explanation="负数补码算术右移补1，正数补码算术右移补0。"
/>

<FillInTheBlank
  :number="7"
  question="原码加减交替除法（不恢复余数法）中，若当前余数为负，则商记为 _________，下一步操作为余数左移后加 _________。"
  :answer='["0", "除数"]'
  explanation="不恢复余数法逻辑：余数为正商1，余数为负商0，然后根据商值决定下一步操作。"
/>

<FillInTheBlank
  :number="8"
  question="浮点加减运算的对阶原则是：_________ 阶向 _________ 阶看齐。"
  :answer='["小", "大"]'
  explanation="对阶原则：只能右移尾数，不能左移，因此小阶向大阶看齐。"
/>

<FillInTheBlank
  :number="9"
  question="补码规格化浮点数的尾数 $M$ 应满足：其符号位 $M_s$ 与最高数值位 $M_1$ 必须 _________。"
  answer="相反（或异或为 1）"
  explanation="规格化：正数规格化 $0.1...$，负数规格化 $1.0...$，符号位与最高数值位必须不同。"
/>

<FillInTheBlank
  :number="10"
  question="当浮点数运算结果出现阶码符号位为01时，表示发生了 _________ 溢出，必须进行中断处理。"
  answer="阶上（或正）"
  explanation="阶码溢出才是真溢出：01正溢出，10负溢出。尾数溢出可以通过右规解决。"
/>

---

## 二、单项选择题（每题 2 分）

<MultipleChoiceQuestion
  :number="1"
  question="（核心考点：移位规则）将 8 位补码 `1110 0100` 算术右移一位后的结果是（ ）。"
  :options='[
    { key: "A", text: "0111 0010" },
    { key: "B", text: "1111 0010", explanation: "补码1110 0100是负数（符号位为1），算术右移时左边补1，得1111 0010。" },
    { key: "C", text: "1111 0011" },
    { key: "D", text: "1110 0010" }
  ]'
  correct-answer="B"
/>

<MultipleChoiceQuestion
  :number="2"
  question="（重点：溢出逻辑）补码运算中，当最高位的进位 $C_s$ 与次高位的进位 $C_1$（ ）时，表示发生了溢出。"
  :options='[
    { key: "A", text: "$C_s = C_1$" },
    { key: "B", text: "$C_s \\neq C_1$", explanation: "溢出判断：$C_s \\oplus C_1 = 1$ 时溢出，即$C_s \\neq C_1$时溢出。这是单符号位补码溢出的判断方法。" },
    { key: "C", text: "$C_s = 0$" },
    { key: "D", text: "$C_1 = 1$" }
  ]'
  correct-answer="B"
/>

<MultipleChoiceQuestion
  :number="3"
  question="（Booth 算法逻辑）补码一位乘法中，乘数 $y = 0.1101$，则需增加的附加位 $y_{n+1}$ 的初值是（ ）。"
  :options='[
    { key: "A", text: "1" },
    { key: "B", text: "0", explanation: "$y_{n+1}$ 初始必须为0，这是Booth算法的要求，用于判断最后一步操作。" },
    { key: "C", text: "与符号位相同" },
    { key: "D", text: "任意" }
  ]'
  correct-answer="B"
/>

<MultipleChoiceQuestion
  :number="4"
  question="（除法计算逻辑）在补码加减交替除法中，商的最后一位通常（ ）。"
  :options='[
    { key: "A", text: "恒置 0" },
    { key: "B", text: "恒置 1", explanation: "末位恒置1法简化硬件设计，避免复杂的舍入判断，是常用的实现方法。" },
    { key: "C", text: "根据余数符号确定" },
    { key: "D", text: "舍入处理" }
  ]'
  correct-answer="B"
/>

<MultipleChoiceQuestion
  :number="5"
  question="（浮点对阶陷阱）在对阶操作中，若阶差为 3，则小阶码的尾数应（ ）。"
  :options='[
    { key: "A", text: "左移 3 位" },
    { key: "B", text: "右移 3 位", explanation: "小阶向大阶看齐，尾数必须右移（不能左移，否则会丢失高位有效位）。阶差为3，右移3位。" },
    { key: "C", text: "左移 1 位" },
    { key: "D", text: "不动" }
  ]'
  correct-answer="B"
/>

<MultipleChoiceQuestion
  :number="6"
  question="（规格化判定）老师强调左规/右规。下列属于补码规格化数的是（ ）。"
  :options='[
    { key: "A", text: "0.0110" },
    { key: "B", text: "1.1011" },
    { key: "C", text: "1.0101", explanation: "正数规格化 $0.1...$，负数规格化 $1.0...$。1.0101是负数规格化数（符号位1，最高数值位0）。注意：1.1不是补码规格化。" },
    { key: "D", text: "0.0011" }
  ]'
  correct-answer="C"
/>

<MultipleChoiceQuestion
  :number="7"
  question="（ALU 核心部件）算术逻辑单元（ALU）的核心部件是（ ）。"
  :options='[
    { key: "A", text: "寄存器" },
    { key: "B", text: "多路选择器" },
    { key: "C", text: "加法器", explanation: "ALU的核心是加法器，通过加法器可以实现加减运算，配合其他逻辑电路可以实现各种算术和逻辑运算。" },
    { key: "D", text: "状态寄存器" }
  ]'
  correct-answer="C"
/>

<MultipleChoiceQuestion
  :number="8"
  question="（符号扩展考点）8 位补码 `0xA0` 扩展为 16 位补码的结果是（ ）。"
  :options='[
    { key: "A", text: "0x00A0" },
    { key: "B", text: "0xFFA0", explanation: "0xA0即1010 0000，符号位为1（负数），扩展时前面全补1，得1111 1111 1010 0000 = 0xFFA0。" },
    { key: "C", text: "0x80A0" },
    { key: "D", text: "0xA000" }
  ]'
  correct-answer="B"
/>

<MultipleChoiceQuestion
  :number="9"
  question="（运算转化思想）录音提到：计算机实现减法运算主要通过（ ）实现。"
  :options='[
    { key: "A", text: "直接减法电路" },
    { key: "B", text: "减数求补后与被减数相加", explanation: "计算机通过补码实现减法：$A-B = A+(-B) = A+[B]_补$，即减数求补后与被减数相加。" },
    { key: "C", text: "减数左移一位" },
    { key: "D", text: "被减数求补" }
  ]'
  correct-answer="B"
/>

<MultipleChoiceQuestion
  :number="10"
  question="（浮点数溢出）浮点数运算中，真正的溢出（上溢）取决于（ ）的状态。"
  :options='[
    { key: "A", text: "尾数符号位" },
    { key: "B", text: "阶码符号位", explanation: "尾数溢出可以通过右规解决，阶码溢出才是真死机。阶码符号位为01表示正溢出，10表示负溢出。" },
    { key: "C", text: "尾数最高位" },
    { key: "D", text: "阶码最低位" }
  ]'
  correct-answer="B"
/>

---

## 参考答案与解析

### 一、填空题

1. **3、2**（输入：A, B, Ci-1；输出：S, Ci）
2. **先行进位（或快速进位）**
3. **正、负数**（录音陷阱：双符号位 01正溢，10负溢，11负数，00正数）
4. **$[X]_{补}$**（Booth算法：01加补，10加负补）
5. **n、不移位**（老师强调：Booth法最后一步只加不移）
6. **1**（负数补码算术右移补 1）
7. **0、除数**（不恢复余数法逻辑）
8. **小、大**（对阶原则：只能右移尾数，不能左移）
9. **相反（或异或为 1）**（规格化：$0.1$ 或 $1.0$）
10. **阶上（或正）**（阶码溢出才是真溢出）

### 二、选择题

1. **B** - 补码 `1` 开头是负数，右移补 `1`，得 `1111 0010`
2. **B** - $C_s \oplus C_1 = 1$ 时溢出，单符号位常用逻辑
3. **B** - $y_{n+1}$ 初始必须为 0
4. **B** - 末位恒置 1法简化硬件设计
5. **B** - 小阶向大阶看齐，尾数右移
6. **C** - 正数规格化 $0.1...$，负数规格化 $1.0...$。注意：$1.1$ 不是补码规格化
7. **C** - ALU的核心是加法器
8. **B** - `A0` 即 `1010 0000`，负数扩展前面全补 1
9. **B** - 减数求补后与被减数相加
10. **B** - 尾数溢出可以通过右规解决，阶码溢出才是真死机

---

## 重点提示

1. **算术移位规则**：
   - 正数补码：左移补0，右移补0
   - 负数补码：左移补0，右移补1
   - 符号位不变

2. **溢出判断**：
   - 单符号位：$C_s \oplus C_1 = 1$ 时溢出
   - 双符号位：01正溢，10负溢，11负数，00正数

3. **Booth算法**：
   - $y_{n+1}$ 初始为0
   - 01加补码，10加负补码，00或11只移位
   - 最后一步只加不移

4. **浮点对阶**：
   - 小阶向大阶看齐
   - 只能右移尾数，不能左移
   - 右移可能丢失精度

5. **规格化**：
   - 正数：$0.1...$
   - 负数：$1.0...$
   - 符号位与最高数值位必须不同

6. **溢出处理**：
   - 尾数溢出：右规解决
   - 阶码溢出：真溢出，必须中断处理
